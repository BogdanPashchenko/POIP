:imagesdir: R6IM

= Отчет №6

=== Задание

Измерить температуру микроконтроллера с помощью встроенного датчика темпертуры.

* Прочитать все АЦП в библии все про встроенный датчик температуры на странице 225

* Включить измерение датчика температуры

* Сконфигурировать АЦП

** 12 бит

** Одиночное преобразование

** Регулярные каналы

** Время дискретизации 84 цикла

** Установка EOC после каждого измерения регулярного канала

** Установить первое измерение с канала куда подключен датчик температуры


[source, C]

----
#include "adc1registers.hpp" //for ADC1
#include "adccommonregisters.hpp" //for ADCCommon
#include "gpioaregisters.hpp"  //for Gpioa
#include "gpiocregisters.hpp"  //for Gpioc
#include "rccregisters.hpp"    //for RCC
#include "tim2registers.hpp"   //for TIM2
#include <iostream>
#include <cstdint>
#include <cstddef>

using namespace std;

extern "C"
{
int __low_level_init(void)
{
  //частота
  //Switch on external 8 MHz oscillator
  RCC::CR::HSEON::On::Set();
  while(!RCC::CR::HSERDY::Ready::IsSet())
  {};
  //Switch system clock on external oscillator
  RCC::CFGR::SW::Hse::Set();
  while (!RCC::CFGR::SWS::Hse::IsSet())
  {};
  //Switch on clock on PortA a
  RCC::AHB1ENR::GPIOAEN::Enable::Set(); 
  
   // ************** Setup TIM2 ***********
   // Set Devider PSC to count every 1 ms
   // Set ARR to 5 seconds  overflow
   // Clear Overdlow event flag  
   // Reset counter
   // Enable TIM2 to count
   
    
   //********* ADC1 setup

  //Подключить АЦП к источнику тактирования – устанавливаем бит ADC1EN в регистре RCC::APB2ENR (АЦП тактируется от шины APB2).
  //Switch on clock on ADC1
  RCC::APB2ENR::ADC1EN::Enable::Set();
  //Сконфигурировать порты. Определиться по каким каналам будут проводиться измерения, затем соответствующие выводы портов настроить для работы в аналоговом режиме.
   //Switch On internal tempearture sensor  
  ADC_Common::CCR::TSVREFE::Enable::Set();
  
  //Сконфигурировать АЦП. 
  
  //Установить разрядность в регистре ADC::CR1
  ADC1::CR1::RES::Bits12::Set();
   //Set single conversion mode
  //Установить режим одиночного преобразование в регистре ADC::CR1 (биты CONT и EOCS установить в нужное значение)
  ADC1::CR2::CONT::SingleConversion::Set();
  ADC1::CR2::EOCS::SingleConversion::Set();   
  // Set laentgh of conversion sequence to 1
  //Установить количество измерений 1 в регистре ADC1::SQR1 бит L
  ADC1::SQR1::L::Conversions1::Set();
  // Connect first conversion on Channel 18 
  //Выбрать канал для первого преобразования в регистре ADC1::SQR3 биты SQ1
  ADC1::SQR3::SQ1::Channel18::Set();
  // Set 84 (3) cycles sample rate for channel 18
  //Установить скорость дискретизации в регистре SMPRx для нужного канала
  ADC1::SMPR1::SMP18::Cycles84::Set();
  ADC1::CR1::SCAN::Enable::Set();
  //Включить АЦП. Это делается установкой бита ADON в регистре ADC::CR2.
  ADC1::CR2::ADON::Enable::Set();
  
  return 1;
}
}

constexpr float B1 = 25.0F - 0.76F/0.0025F ;// see datacheet (page 226) and calculate B coeficient here ;
constexpr float K1 = 3.3F/(4096.0F*0.0025F); // see datcheet  (page 226) and calculate K coeficient here ; 

int main()
{
  std::uint32_t data = 0U ;
  float temperature = 0.0F ;
  
  for(;;)    
  {
    //**************ADC*****************
    // Enable ADC1
    
    //Start conversion
    //Запустить АЦП на преобразование установкой бита SWSTART в регистре ADC::CR2 для регулярных каналов
    ADC1::CR2::SWSTART::On::Set();
    
    // wait until Conversion is not complete 
    //Дождаться готовности бита EOC в регистре ADC::SR
    while(!ADC1::SR::EOC::ConversionComplete::IsSet())
    {};
    data =   ADC1::DR::Get(); //Get data from ADC;
    temperature = data * K1 + B1 ; //Convert ADC counts to temperature

            
  std::cout << "Count: " << data << " Temperature: " << temperature << std::endl ;

}
return 0;  
}
----

image::Figure5.png[] 



==== * Задание 

Калибровочные значения: 

image::Figure1.png[] 

Нужные нам значения лежат по адресам:

для 30 °C : 0x1FFF 7A2C - 0x1FFF 7A2D

image::Figure2.png[] 

для 110 °C: 0x1FFF 7A2E - 0x1FFF 7A2F

image::Figure3.png[] 


[source, C]

----
constexpr size_t T30Addr = 0x1FFF7A2C;
constexpr size_t T110Addr =  0x1FFF7A2E;

int main()
{
    
  volatile uint32_t *T30Pointer = reinterpret_cast<volatile uint32_t*>(T30Addr) ;
  volatile uint32_t *T110Pointer = reinterpret_cast<volatile uint32_t*>(T110Addr) ;

  uint32_t T30 = *T30Pointer;
  uint32_t T110 = *T110Pointer;
----

image::Figure4.png[]

Вопрос: как именно нужно использовать данные значения длы получения температуры?

